name: Update Factory Issues

on:
  # Trigger when partner or stage changes happen in study repos
  repository_dispatch:
    types: [update_factory_issue]
  
  # Manual trigger for maintenance
  workflow_dispatch:
    inputs:
      study_repo:
        description: 'Specific study repo to update (optional, format: owner/repo)'
        required: false
        type: string

  # Scheduled refresh to catch any missed updates
  schedule:
    - cron: "0 6 * * *"  # Daily at 6 AM UTC

permissions:
  contents: read
  issues: write

jobs:
  update_factory_issues:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
      ORG_LOGIN: ${{ github.repository_owner }}
      FACTORY_REPO: ${{ github.repository }}
      FACTORY_PROJECT_NUMBER: ${{ vars.FACTORY_PROJECT_NUMBER }}
    
    steps:
      - name: Get Factory issues to update
        id: get_issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const factoryRepo = process.env.FACTORY_REPO;
            const [owner, repo] = factoryRepo.split('/');
            const specificRepo = "${{ inputs.study_repo }}" || null;
            
            console.log('Fetching Factory issues to update...');
            
            try {
              const issues = await github.rest.issues.listForRepo({
                owner,
                repo,
                labels: 'study',
                state: 'open',
                per_page: 100
              });
              
              let issuesToUpdate = [];
              
              for (const issue of issues.data) {
                // Extract study repo from issue body
                const repoMatch = issue.body?.match(/\*\*Repository\*\*:.*?github\.com\/([^\/\s\)]+\/[^\/\s\)]+)/);
                if (repoMatch) {
                  const studyRepo = repoMatch[1];
                  
                  // If specific repo requested, only update that one
                  if (!specificRepo || studyRepo === specificRepo) {
                    issuesToUpdate.push({
                      number: issue.number,
                      title: issue.title,
                      studyRepo: studyRepo,
                      body: issue.body
                    });
                  }
                }
              }
              
              console.log(`Found ${issuesToUpdate.length} Factory issues to update`);
              core.setOutput('issues', JSON.stringify(issuesToUpdate));
              
              return issuesToUpdate;
              
            } catch (error) {
              console.error('Error fetching Factory issues:', error);
              core.setFailed(`Failed to fetch Factory issues: ${error.message}`);
            }

      - name: Update each Factory issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const factoryRepo = process.env.FACTORY_REPO;
            const [factoryOwner, factoryRepoName] = factoryRepo.split('/');
            const issues = JSON.parse('${{ steps.get_issues.outputs.issues }}');
            
            for (const factoryIssue of issues) {
              console.log(`Updating Factory issue #${factoryIssue.number}: ${factoryIssue.title}`);
              
              try {
                const [studyOwner, studyRepo] = factoryIssue.studyRepo.split('/');
                
                // Get status tracking issues from study repo
                const statusIssues = await github.rest.issues.listForRepo({
                  owner: studyOwner,
                  repo: studyRepo,
                  labels: 'status-tracking',
                  state: 'all',
                  per_page: 100
                });
                
                // Note: Legacy stage-based system removed in favor of objective-based tracking
                
                // Build status tracking section
                let statusSection = "## üéØ Study Progress\n\n";
                
                if (statusIssues.data.length === 0) {
                  statusSection += "No status tracking issues found.\n";
                } else {
                  statusSection += "| Milestone | Status | Last Updated |\n";
                  statusSection += "|-----------|--------|-------------|\n";
                  
                  // Sort by order (extract number from title like "1) Analysis Package Prototype")
                  const sortedStatus = statusIssues.data.sort((a, b) => {
                    const aOrder = parseInt(a.title.match(/^(\d+)\)/) ? a.title.match(/^(\d+)\)/)[1] : 999);
                    const bOrder = parseInt(b.title.match(/^(\d+)\)/) ? b.title.match(/^(\d+)\)/)[1] : 999);
                    return aOrder - bOrder;
                  });
                  
                  for (const statusIssue of sortedStatus) {
                    const milestoneTitle = statusIssue.title.replace(/^\d+\)\s*/, ''); // Remove order number
                    const status = statusIssue.state === 'closed' ? '‚úÖ Complete' : 
                                 statusIssue.assignees?.length > 0 ? 'üîÑ In Progress' : '‚è≥ Pending';
                    const lastUpdated = new Date(statusIssue.updated_at).toLocaleDateString();
                    
                    statusSection += `| [${milestoneTitle}](${statusIssue.html_url}) | ${status} | ${lastUpdated} |\n`;
                  }
                }
                
                // Build setup checklist section  
                let checklistSection = "\n## ‚úÖ Factory Setup Checklist\n\n";
                
                const checklistItems = [
                  { name: "Study repository created from template", check: () => true }, // If we're here, repo exists
                  { name: "Per-study project created and linked", check: () => true }, // TODO: Could validate this
                  { name: "Status tracking issues created (3 objectives)", check: () => statusIssues.data.length >= 3 },
                  { name: "Repository permissions configured", check: () => true }, // TODO: Could validate this
                  { name: "Factory automation workflows active", check: () => true }, // TODO: Could check workflow files
                  { name: "Study lead has admin access", check: () => true }, // TODO: Could validate permissions
                ];
                
                for (const item of checklistItems) {
                  const checked = item.check() ? "x" : " ";
                  checklistSection += `- [${checked}] ${item.name}\n`;
                }
                
                // Build study history section based on objectives
                let historySection = "\n## üìä Study History\n\n";
                
                // Get objectives configuration from study-status-issues.json
                let objectives = [];
                try {
                  const configResponse = await github.rest.repos.getContent({
                    owner: factoryOwner,
                    repo: factoryRepoName,
                    path: '.github/data/study-status-issues.json'
                  });
                  
                  const configContent = Buffer.from(configResponse.data.content, 'base64').toString('utf-8');
                  const config = JSON.parse(configContent);
                  objectives = config.issues.sort((a, b) => a.order - b.order);
                } catch (error) {
                  console.log('Could not load objectives configuration:', error.message);
                  // Fallback to hardcoded objectives
                  objectives = [
                    { order: 1, title: "1) Analysis Package Prototype", factory_objective: "Analysis Package Prototype" },
                    { order: 2, title: "2) Network Execution", factory_objective: "Network Execution" },
                    { order: 3, title: "3) Journal Submission", factory_objective: "Journal Submission" }
                  ];
                }
                
                historySection += "| Objective | Date Complete |\n";
                historySection += "|-----------|---------------|\n";
                
                for (const objective of objectives) {
                  // Find corresponding status-tracking issue in study repo
                  const statusIssue = statusIssues.data.find(issue => 
                    issue.title === objective.title || 
                    issue.title.includes(objective.factory_objective)
                  );
                  
                  if (statusIssue) {
                    const objectiveLink = `[${objective.factory_objective}](${statusIssue.html_url})`;
                    const dateComplete = statusIssue.state === 'closed' 
                      ? new Date(statusIssue.closed_at).toLocaleDateString()
                      : '‚Äî';
                    
                    historySection += `| ${objectiveLink} | ${dateComplete} |\n`;
                  } else {
                    historySection += `| ${objective.factory_objective} | ‚Äî |\n`;
                  }
                }
                
                // Reconstruct the Factory issue body
                const headerMatch = factoryIssue.body.match(/^([\s\S]*?)(?=## üéØ Study Progress|## üìä Data Partners Status|## ‚úÖ Factory Setup Checklist)/);
                const footerMatch = factoryIssue.body.match(/(---[\s\S]*?This issue is automatically maintained[\s\S]*?)$/);
                
                let header = "# Study Overview\n\n*Study details will be populated from repository information*\n\n";
                if (headerMatch) {
                  header = headerMatch[1].trim() + "\n\n";
                }
                
                const footer = footerMatch ? footerMatch[1] : "\n\n---\n*This issue is automatically maintained by Factory automation workflows.*";
                
                const newBody = header + statusSection + checklistSection + historySection + footer;
                
                // Update the Factory issue
                await github.rest.issues.update({
                  owner: factoryOwner,
                  repo: factoryRepoName,
                  issue_number: factoryIssue.number,
                  body: newBody
                });
                
                console.log(`‚úÖ Updated Factory issue #${factoryIssue.number}`);
                
              } catch (error) {
                console.error(`‚ùå Failed to update Factory issue #${factoryIssue.number}:`, error.message);
                // Continue with other issues rather than failing the whole job
              }
            }
            
            console.log('‚úÖ Finished updating Factory issues');